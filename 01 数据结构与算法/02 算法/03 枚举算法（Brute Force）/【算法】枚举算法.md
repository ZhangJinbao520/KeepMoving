<!-- @author: Zhang Jinbao -->

<!-- @date: 2022-04-14 19:10:35 -->

[TOC]

---

## 枚举算法

枚举算法（**enum**）又称**穷枚举**，指的是从问题所有可能的解的集合中一一枚举各元素。

- 优点
  - 算法简单粗暴
- 缺点
  - 复杂度高
  - 运算量大
  - …

- 使用限制
  - 枚举值必须定义在一个有限范围内
  - 枚举值必须为常量
  - 枚举算法运算速率慢，一般需要进行**剪枝**
  - …



### 朴素枚举

借助<font color="red"> **$for$ 循环**</font>枚举所有情况。



### 状压枚举

借助<font color="red"> **$n$ 进制**</font>进行枚举。

> ***💬说明：*** *状压即为状态压缩，将多个状态压缩映射为 1 个进制值。*

- 适用场景

  $m$ 件物品，每件物品有 $n$ 种状态，枚举所有物品的所有状态。

  > ***💬说明：*** *复杂度为 $O(n^m)$。*



## 算法模型

使用该算法需要满足以下前提条件：

- 可预先确定候选答案的数量
- 候选答案的范围在求解之前必须有一个确定的集合



## 举个栗子🌰

### 二进制状压枚举

- 总共有 $n$ 个数：$a_1,a_2,\ldots,a_n$，每个数可取可不取，一共有多少种求和方案？

```python
n = [1, 2, 3]
res = []

# 复杂度为 O(n*2^n)
for i in range(2 ** len(n)):
    temp = 0
    for _j in n:
        if i % 2 == 0:
            temp += 0
        if i % 2 == 1:
            temp += _j
        # 求下一个 n 进制位
        i //= 2
    res.append(temp)

print(res)  # [0, 1, 2, 3, 3, 4, 5, 6]
```



- 代码优化

  使用 dp 优化

```python
n = [1, 2, 3]
# 求最大和
total = sum(n)
# 假设各个和映射的值
dp = [0] * (total + 1)
dp[0] = 1

# 复杂度为 O(n*2^n)
for i in n:
    for j in range(total, i-1, -1):
        dp[j] += dp[j-i]

print(dp)  # [1, 1, 1, 2, 1, 1, 1]
```

